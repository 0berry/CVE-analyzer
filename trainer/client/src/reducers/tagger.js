import {
  DELETE_ASSIGNED_LABEL,
  ADD_ASSIGNED_LABEL,
  REC_SUBMIT_LABELS_ERR,
  REC_SUBMIT_LABELS_RES,
  REQ_SUBMIT_LABELS,
  REQ_NEXT_CVE,
  REC_NEXT_CVE_RES,
  REC_NEXT_CVE_ERR,
  RESET_ERROR
} from '../constants/actionTypes';

const initialState = {
  // TODO: The available labels are here because we plan to support insertion of new labels server side.
  availableLabels: [
    { key: 0, label: 'Struct', color: '#d50000', description: 'Malformed struct that contains the bug' },
    { key: 1, label: 'Driver' , color: '#AA00FF', description: 'Driver that we the attacker needs to interact with to trigger the exploit' },
    { key: 2, label: 'Version', color: '#304FFE', description: 'Vulnerable version of the target program' },
    { key: 3, label: 'Function', color: '#00BFA5', description: 'Vulnerable function name' },
    { key: 4, label: 'Capability', color: '#64DD17', description: 'Capability that the attacker gains after a successful exploitation of the vulnerability (e.g. denial of service, etc...)' },
    { key: 5, label: 'Vulnerability', color: '#FFAB00', description: 'Type of the vulnerability (e.g. buffer overflow, etc...)' },
    { key: 6, label: 'Source Code', color: '#FF6D00', description: 'Path to the source code that contains the vulnerable function/functions' },
  ],
  currentCveId: "",
  currentAnalyzedCve: "Loading...",
  currentAssignedLabels: [
  ],
  error: '',
  isLoading: false,
  isSubmitting: false
};

export default function TaggerReducer(state = initialState, action) {
  switch (action.type) {
    case DELETE_ASSIGNED_LABEL:
      const updatedAssignLabels = state.currentAssignedLabels.filter(label => label.start !== action.payload);
      return { ...state, currentAssignedLabels: updatedAssignLabels };
    case ADD_ASSIGNED_LABEL:
      return { ...state, currentAssignedLabels: [action.payload, ...state.currentAssignedLabels ]};
    case REQ_SUBMIT_LABELS:
      return { ...state, isSubmitting: true };
    case REC_SUBMIT_LABELS_RES:
      return { ...state, isSubmitting: false, error: '' };
    case REC_SUBMIT_LABELS_ERR:
      return { ...state, isSubmitting: false, error: action.payload.response.data.error };
    case REQ_NEXT_CVE:
      return { ...state, isLoading: true };
    case REC_NEXT_CVE_RES:
      const resultNextCve = action.payload.data.data;
      return {
        ...state, isLoading: false, error: '', currentCveId: resultNextCve.cve_id,
        currentAnalyzedCve: resultNextCve.cve_description, currentAssignedLabels: []
      };
    case REC_NEXT_CVE_ERR:
      return { ...state, isLoading: false, error: action.payload.response.data.error };
    case RESET_ERROR:
      return { ...state, error: ''};
    default:
      return state;
  }
}